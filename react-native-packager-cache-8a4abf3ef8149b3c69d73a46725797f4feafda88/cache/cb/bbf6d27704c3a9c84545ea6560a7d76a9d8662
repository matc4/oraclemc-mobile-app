Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react2 = require('react');

var _react3 = _interopRequireDefault(_react2);

var _index2 = require('./../../../react-transform-hmr/lib/index.js');

var _index3 = _interopRequireDefault(_index2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class,
    _temp,
    _jsxFileName = '/Users/dev2/Documents/Proyectos/oraclemc-mobile-app/node_modules/react-native-snap-carousel/src/carousel/Carousel.js';

var _reactNative = require('react-native');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactAddonsShallowCompare = require('react-addons-shallow-compare');

var _reactAddonsShallowCompare2 = _interopRequireDefault(_reactAddonsShallowCompare);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _components = {
    Carousel: {
        displayName: 'Carousel'
    }
};

var _reactTransformHmrLibIndexJs2 = (0, _index3.default)({
    filename: '/Users/dev2/Documents/Proyectos/oraclemc-mobile-app/node_modules/react-native-snap-carousel/src/carousel/Carousel.js',
    components: _components,
    locals: [module],
    imports: [_react3.default]
});

function _wrapComponent(id) {
    return function (Component) {
        return _reactTransformHmrLibIndexJs2(Component, id);
    };
}

var IS_IOS = _reactNative.Platform.OS === 'ios';

var AnimatedFlatList = _reactNative.Animated.createAnimatedComponent(_reactNative.FlatList);

var IS_RTL = _reactNative.I18nManager.isRTL;

var Carousel = _wrapComponent('Carousel')((_temp = _class = function (_Component) {
    _inherits(Carousel, _Component);

    function Carousel(props) {
        _classCallCheck(this, Carousel);

        var _this = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, props));

        _this.state = {
            hideCarousel: true,
            interpolators: []
        };

        var initialActiveItem = _this._getFirstItem(props.firstItem);
        _this._activeItem = initialActiveItem;
        _this._previousActiveItem = initialActiveItem;
        _this._previousFirstItem = initialActiveItem;
        _this._previousItemsLength = initialActiveItem;

        _this._positions = [];
        _this._currentContentOffset = 0;
        _this._canFireCallback = false;
        _this._scrollOffsetRef = null;
        _this._onScrollTriggered = true;
        _this._scrollEnabled = props.scrollEnabled === false ? false : true;

        _this._getItemLayout = _this._getItemLayout.bind(_this);
        _this._initPositionsAndInterpolators = _this._initPositionsAndInterpolators.bind(_this);
        _this._renderItem = _this._renderItem.bind(_this);
        _this._onSnap = _this._onSnap.bind(_this);

        _this._onLayout = _this._onLayout.bind(_this);
        _this._onScroll = _this._onScroll.bind(_this);
        _this._onScrollBeginDrag = props.enableSnap ? _this._onScrollBeginDrag.bind(_this) : undefined;
        _this._onScrollEnd = props.enableSnap || props.autoplay ? _this._onScrollEnd.bind(_this) : undefined;
        _this._onScrollEndDrag = !props.enableMomentum ? _this._onScrollEndDrag.bind(_this) : undefined;
        _this._onMomentumScrollEnd = props.enableMomentum ? _this._onMomentumScrollEnd.bind(_this) : undefined;
        _this._onTouchStart = _this._onTouchStart.bind(_this);
        _this._onTouchRelease = _this._onTouchRelease.bind(_this);

        var scrollEventConfig = {
            listener: _this._onScroll,
            useNativeDriver: true
        };
        _this._scrollPos = new _reactNative.Animated.Value(0);
        _this._onScrollHandler = props.vertical ? _reactNative.Animated.event([{ nativeEvent: { contentOffset: { y: _this._scrollPos } } }], scrollEventConfig) : _reactNative.Animated.event([{ nativeEvent: { contentOffset: { x: _this._scrollPos } } }], scrollEventConfig);

        _this._ignoreNextMomentum = false;

        if (!_reactNative.ViewPropTypes) {
            console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');
        }
        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {
            console.warn('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');
        }
        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {
            console.warn('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');
        }
        if (props.onScrollViewScroll) {
            console.warn('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');
        }
        return _this;
    }

    _createClass(Carousel, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            var apparitionDelay = this.props.apparitionDelay;


            this._initPositionsAndInterpolators();

            if (apparitionDelay) {
                this._apparitionTimeout = setTimeout(function () {
                    _this2._didMountDelayedInit();
                }, apparitionDelay);
            } else {
                this._didMountDelayedInit();
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
            if (this.props.shouldOptimizeUpdates === false) {
                return true;
            } else {
                return (0, _reactAddonsShallowCompare2.default)(this, nextProps, nextState);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var interpolators = this.state.interpolators;
            var firstItem = nextProps.firstItem,
                itemHeight = nextProps.itemHeight,
                itemWidth = nextProps.itemWidth,
                sliderHeight = nextProps.sliderHeight,
                sliderWidth = nextProps.sliderWidth;

            var itemsLength = this._getCustomDataLength(nextProps);

            if (!itemsLength) {
                return;
            }

            var nextFirstItem = this._getFirstItem(firstItem, nextProps);
            var nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;

            var hasNewSliderWidth = sliderWidth && sliderWidth !== this.props.sliderWidth;
            var hasNewSliderHeight = sliderHeight && sliderHeight !== this.props.sliderHeight;
            var hasNewItemWidth = itemWidth && itemWidth !== this.props.itemWidth;
            var hasNewItemHeight = itemHeight && itemHeight !== this.props.itemHeight;

            if (nextActiveItem > itemsLength - 1) {
                nextActiveItem = itemsLength - 1;
            }

            if (interpolators.length !== itemsLength || hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {
                this._activeItem = nextActiveItem;
                this._previousItemsLength = itemsLength;

                this._initPositionsAndInterpolators(nextProps);

                if (this._previousItemsLength > itemsLength) {
                    this._hackActiveSlideAnimation(nextActiveItem, null, true);
                }

                if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {
                    this.snapToItem(nextActiveItem, false, false, false, false);
                }
            } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {
                this._activeItem = nextFirstItem;
                this._previousFirstItem = nextFirstItem;
                this.snapToItem(nextFirstItem, true, true, false, false);
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.stopAutoplay();
            clearTimeout(this._apparitionTimeout);
            clearTimeout(this._hackSlideAnimationTimeout);
            clearTimeout(this._enableAutoplayTimeout);
            clearTimeout(this._autoplayTimeout);
            clearTimeout(this._snapNoMomentumTimeout);
            clearTimeout(this._edgeItemTimeout);
            clearTimeout(this._lockScrollTimeout);
        }
    }, {
        key: '_shouldAnimateSlides',
        value: function _shouldAnimateSlides() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
            var inactiveSlideOpacity = props.inactiveSlideOpacity,
                inactiveSlideScale = props.inactiveSlideScale;

            return inactiveSlideOpacity < 1 || inactiveSlideScale < 1;
        }
    }, {
        key: '_needsRTLAdaptations',
        value: function _needsRTLAdaptations() {
            var vertical = this.props.vertical;

            return IS_RTL && !IS_IOS && !vertical;
        }
    }, {
        key: '_canLockScroll',
        value: function _canLockScroll() {
            var _props = this.props,
                enableMomentum = _props.enableMomentum,
                lockScrollWhileSnapping = _props.lockScrollWhileSnapping;

            return !enableMomentum && lockScrollWhileSnapping;
        }
    }, {
        key: '_enableLoop',
        value: function _enableLoop() {
            var _props2 = this.props,
                data = _props2.data,
                enableSnap = _props2.enableSnap,
                loop = _props2.loop;

            return enableSnap && loop && data.length && data.length > 1;
        }
    }, {
        key: '_getCustomData',
        value: function _getCustomData() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
            var data = props.data,
                loopClonesPerSide = props.loopClonesPerSide;

            var dataLength = data.length;

            if (!data || !dataLength) {
                return [];
            }

            if (!this._enableLoop()) {
                return data;
            }

            var previousItems = [];
            var nextItems = [];

            if (loopClonesPerSide > dataLength) {
                var _previousItems2, _nextItems2;

                var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
                var remainder = loopClonesPerSide % dataLength;

                for (var i = 0; i < dataMultiplier; i++) {
                    var _previousItems, _nextItems;

                    (_previousItems = previousItems).push.apply(_previousItems, _toConsumableArray(data));
                    (_nextItems = nextItems).push.apply(_nextItems, _toConsumableArray(data));
                }

                (_previousItems2 = previousItems).unshift.apply(_previousItems2, _toConsumableArray(data.slice(-remainder)));
                (_nextItems2 = nextItems).push.apply(_nextItems2, _toConsumableArray(data.slice(0, remainder)));
            } else {
                previousItems = data.slice(-loopClonesPerSide);
                nextItems = data.slice(0, loopClonesPerSide);
            }

            return previousItems.concat(data, nextItems);
        }
    }, {
        key: '_getCustomDataLength',
        value: function _getCustomDataLength() {
            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
            var data = props.data,
                loopClonesPerSide = props.loopClonesPerSide;

            var dataLength = data && data.length;

            if (!dataLength) {
                return 0;
            }

            return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;
        }
    }, {
        key: '_getCustomIndex',
        value: function _getCustomIndex(index) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;

            var itemsLength = this._getCustomDataLength(props);

            if (!itemsLength || !index && index !== 0) {
                return 0;
            }

            return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;
        }
    }, {
        key: '_getDataIndex',
        value: function _getDataIndex(index) {
            var _props3 = this.props,
                data = _props3.data,
                loopClonesPerSide = _props3.loopClonesPerSide;

            var dataLength = data && data.length;

            if (!this._enableLoop() || !dataLength) {
                return index;
            }

            if (index >= dataLength + loopClonesPerSide) {
                return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;
            } else if (index < loopClonesPerSide) {
                if (loopClonesPerSide > dataLength) {
                    var baseDataIndexes = [];
                    var dataIndexes = [];
                    var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
                    var remainder = loopClonesPerSide % dataLength;

                    for (var i = 0; i < dataLength; i++) {
                        baseDataIndexes.push(i);
                    }

                    for (var j = 0; j < dataMultiplier; j++) {
                        dataIndexes.push.apply(dataIndexes, baseDataIndexes);
                    }

                    dataIndexes.unshift.apply(dataIndexes, _toConsumableArray(baseDataIndexes.slice(-remainder)));
                    return dataIndexes[index];
                } else {
                    return index + dataLength - loopClonesPerSide;
                }
            } else {
                return index - loopClonesPerSide;
            }
        }
    }, {
        key: '_getPositionIndex',
        value: function _getPositionIndex(index) {
            var _props4 = this.props,
                loop = _props4.loop,
                loopClonesPerSide = _props4.loopClonesPerSide;

            return loop ? index + loopClonesPerSide : index;
        }
    }, {
        key: '_getFirstItem',
        value: function _getFirstItem(index) {
            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;
            var loopClonesPerSide = props.loopClonesPerSide;

            var itemsLength = this._getCustomDataLength(props);

            if (!itemsLength || index > itemsLength - 1 || index < 0) {
                return 0;
            }

            return this._enableLoop() ? index + loopClonesPerSide : index;
        }
    }, {
        key: '_getScrollEnabled',
        value: function _getScrollEnabled() {
            return this._scrollEnabled;
        }
    }, {
        key: '_setScrollEnabled',
        value: function _setScrollEnabled() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            if (this.props.scrollEnabled === false || !this._flatlist || !this._flatlist.setNativeProps) {
                return;
            }

            this._flatlist.setNativeProps({ scrollEnabled: value });
            this._scrollEnabled = value;
        }
    }, {
        key: '_getKeyExtractor',
        value: function _getKeyExtractor(item, index) {
            return 'carousel-item-' + index;
        }
    }, {
        key: '_getItemLayout',
        value: function _getItemLayout(data, index) {
            var _props5 = this.props,
                itemWidth = _props5.itemWidth,
                itemHeight = _props5.itemHeight,
                vertical = _props5.vertical;

            var itemSize = vertical ? itemHeight : itemWidth;

            return {
                length: itemSize,
                offset: itemSize * index,
                index: index
            };
        }
    }, {
        key: '_getScrollOffset',
        value: function _getScrollOffset(event) {
            var vertical = this.props.vertical;

            return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;
        }
    }, {
        key: '_getContainerInnerMargin',
        value: function _getContainerInnerMargin() {
            var opposite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            var _props6 = this.props,
                sliderWidth = _props6.sliderWidth,
                sliderHeight = _props6.sliderHeight,
                itemWidth = _props6.itemWidth,
                itemHeight = _props6.itemHeight,
                vertical = _props6.vertical,
                activeSlideAlignment = _props6.activeSlideAlignment;


            if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {
                return 0;
            } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {
                return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;
            } else {
                return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;
            }
        }
    }, {
        key: '_getViewportOffet',
        value: function _getViewportOffet() {
            var _props7 = this.props,
                sliderWidth = _props7.sliderWidth,
                sliderHeight = _props7.sliderHeight,
                itemWidth = _props7.itemWidth,
                itemHeight = _props7.itemHeight,
                vertical = _props7.vertical,
                activeSlideAlignment = _props7.activeSlideAlignment;


            if (activeSlideAlignment === 'start') {
                return vertical ? itemHeight / 2 : itemWidth / 2;
            } else if (activeSlideAlignment === 'end') {
                return vertical ? sliderHeight - itemHeight / 2 : sliderWidth - itemWidth / 2;
            } else {
                return vertical ? sliderHeight / 2 : sliderWidth / 2;
            }
        }
    }, {
        key: '_getCenter',
        value: function _getCenter(offset) {
            return offset + this._getViewportOffet() - this._getContainerInnerMargin();
        }
    }, {
        key: '_getActiveItem',
        value: function _getActiveItem(offset) {
            var _props8 = this.props,
                activeSlideOffset = _props8.activeSlideOffset,
                swipeThreshold = _props8.swipeThreshold;

            var center = this._getCenter(offset);
            var centerOffset = activeSlideOffset || swipeThreshold;

            for (var i = 0; i < this._positions.length; i++) {
                var _positions$i = this._positions[i],
                    start = _positions$i.start,
                    end = _positions$i.end;

                if (center + centerOffset >= start && center - centerOffset <= end) {
                    return i;
                }
            }

            var lastIndex = this._positions.length - 1;
            if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {
                return lastIndex;
            }

            return 0;
        }
    }, {
        key: '_didMountDelayedInit',
        value: function _didMountDelayedInit() {
            var _props9 = this.props,
                firstItem = _props9.firstItem,
                autoplay = _props9.autoplay;

            var _firstItem = this._getFirstItem(firstItem);

            this.snapToItem(_firstItem, false, false, true, false);
            this._hackActiveSlideAnimation(_firstItem, 'start', true);
            this.setState({ hideCarousel: false });

            if (autoplay) {
                this.startAutoplay();
            }
        }
    }, {
        key: '_initPositionsAndInterpolators',
        value: function _initPositionsAndInterpolators() {
            var _this3 = this;

            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
            var data = props.data,
                itemWidth = props.itemWidth,
                itemHeight = props.itemHeight,
                vertical = props.vertical;

            var sizeRef = vertical ? itemHeight : itemWidth;

            if (!data.length) {
                return;
            }

            var interpolators = [];
            this._positions = [];

            this._getCustomData(props).forEach(function (itemData, index) {
                var _index = _this3._getCustomIndex(index, props);
                var start = (_index - 1) * sizeRef;
                var middle = _index * sizeRef;
                var end = (_index + 1) * sizeRef;
                var value = _this3._shouldAnimateSlides(props) ? _this3._scrollPos.interpolate({
                    inputRange: [start, middle, end],
                    outputRange: [0, 1, 0],
                    extrapolate: 'clamp'
                }) : 1;

                _this3._positions[index] = {
                    start: index * sizeRef,
                    end: index * sizeRef + sizeRef
                };

                interpolators.push({
                    opacity: value,
                    scale: value
                });
            });

            this.setState({ interpolators: interpolators });
        }
    }, {
        key: '_hackActiveSlideAnimation',
        value: function _hackActiveSlideAnimation(index, goTo) {
            var _this4 = this;

            var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var _props10 = this.props,
                data = _props10.data,
                vertical = _props10.vertical;


            if (IS_IOS || !this._flatlist || !this._positions[index] || !force && this._enableLoop()) {
                return;
            }

            var offset = this._positions[index] && this._positions[index].start;

            if (!offset) {
                return;
            }

            var itemsLength = data && data.length;
            var direction = goTo || itemsLength === 1 ? 'start' : 'end';
            var commonOptions = {
                horizontal: !vertical,
                animated: false
            };

            this._flatlist && this._flatlist._listRef && this._flatlist.scrollToOffset(_extends({
                offset: offset + (direction === 'start' ? -1 : 1)
            }, commonOptions));

            this._hackSlideAnimationTimeout = setTimeout(function () {
                _this4._flatlist && _this4._flatlist._listRef && _this4._flatlist.scrollToOffset(_extends({
                    offset: offset
                }, commonOptions));
            }, 50);
        }
    }, {
        key: '_lockScroll',
        value: function _lockScroll() {
            var _this5 = this;

            clearTimeout(this._lockScrollTimeout);
            this._lockScrollTimeout = setTimeout(function () {
                _this5._releaseScroll();
            }, 1000);
            this._setScrollEnabled(false);
        }
    }, {
        key: '_releaseScroll',
        value: function _releaseScroll() {
            clearTimeout(this._lockScrollTimeout);
            this._setScrollEnabled(true);
        }
    }, {
        key: '_repositionScroll',
        value: function _repositionScroll(index) {
            var _props11 = this.props,
                data = _props11.data,
                loopClonesPerSide = _props11.loopClonesPerSide;

            var dataLength = data && data.length;

            if (!this._enableLoop() || !dataLength || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {
                return;
            }

            var repositionTo = index;

            if (index >= dataLength + loopClonesPerSide) {
                repositionTo = index - dataLength;
            } else if (index < loopClonesPerSide) {
                repositionTo = index + dataLength;
            }

            this.snapToItem(repositionTo, false, false, false, false);
        }
    }, {
        key: '_onScroll',
        value: function _onScroll(event) {
            var _props12 = this.props,
                enableMomentum = _props12.enableMomentum,
                onScroll = _props12.onScroll,
                callbackOffsetMargin = _props12.callbackOffsetMargin;


            var scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;
            var nextActiveItem = this._getActiveItem(scrollOffset);
            var scrollConditions = nextActiveItem === this._itemToSnapTo && scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin && scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;

            this._currentContentOffset = scrollOffset;
            this._onScrollTriggered = true;

            if (enableMomentum) {
                clearTimeout(this._snapNoMomentumTimeout);

                if (this._activeItem !== nextActiveItem) {
                    this._activeItem = nextActiveItem;
                }

                if (scrollConditions && this._canFireCallback) {
                    this._onSnap(this._getDataIndex(nextActiveItem));
                }
            } else if (scrollConditions && this._activeItem !== nextActiveItem) {
                this._activeItem = nextActiveItem;

                if (this._canLockScroll()) {
                    this._releaseScroll();
                }

                if (this._canFireCallback) {
                    this._onSnap(this._getDataIndex(nextActiveItem));
                }
            }

            if (nextActiveItem === this._itemToSnapTo && scrollOffset === this._scrollOffsetRef) {
                this._repositionScroll(nextActiveItem);
            }

            if (onScroll && event) {
                onScroll(event);
            }
        }
    }, {
        key: '_onStartShouldSetResponderCapture',
        value: function _onStartShouldSetResponderCapture(event) {
            var onStartShouldSetResponderCapture = this.props.onStartShouldSetResponderCapture;


            if (onStartShouldSetResponderCapture) {
                onStartShouldSetResponderCapture(event);
            }

            return this._getScrollEnabled();
        }
    }, {
        key: '_onTouchStart',
        value: function _onTouchStart() {
            if (this._getScrollEnabled() !== false && this._autoplaying) {
                this.stopAutoplay();
            }
        }
    }, {
        key: '_onScrollBeginDrag',
        value: function _onScrollBeginDrag(event) {
            var onScrollBeginDrag = this.props.onScrollBeginDrag;


            if (!this._getScrollEnabled()) {
                return;
            }

            this._scrollStartOffset = this._getScrollOffset(event);
            this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);
            this._ignoreNextMomentum = false;


            if (onScrollBeginDrag) {
                onScrollBeginDrag(event);
            }
        }
    }, {
        key: '_onScrollEndDrag',
        value: function _onScrollEndDrag(event) {
            var onScrollEndDrag = this.props.onScrollEndDrag;


            if (this._flatlist) {
                this._onScrollEnd && this._onScrollEnd();
            }

            if (onScrollEndDrag) {
                onScrollEndDrag(event);
            }
        }
    }, {
        key: '_onMomentumScrollEnd',
        value: function _onMomentumScrollEnd(event) {
            var onMomentumScrollEnd = this.props.onMomentumScrollEnd;


            if (this._flatlist) {
                this._onScrollEnd && this._onScrollEnd();
            }

            if (onMomentumScrollEnd) {
                onMomentumScrollEnd(event);
            }
        }
    }, {
        key: '_onScrollEnd',
        value: function _onScrollEnd(event) {
            var _this6 = this;

            var _props13 = this.props,
                autoplay = _props13.autoplay,
                enableSnap = _props13.enableSnap;


            if (this._ignoreNextMomentum) {
                this._ignoreNextMomentum = false;
                return;
            }

            this._scrollEndOffset = this._currentContentOffset;
            this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);

            if (enableSnap) {
                this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);
            }

            if (autoplay) {
                clearTimeout(this._enableAutoplayTimeout);
                this._enableAutoplayTimeout = setTimeout(function () {
                    _this6.startAutoplay();
                }, 300);
            }
        }
    }, {
        key: '_onTouchRelease',
        value: function _onTouchRelease(event) {
            var _this7 = this;

            var enableMomentum = this.props.enableMomentum;


            if (enableMomentum && IS_IOS) {
                clearTimeout(this._snapNoMomentumTimeout);
                this._snapNoMomentumTimeout = setTimeout(function () {
                    _this7.snapToItem(_this7._activeItem);
                }, 100);
            }
        }
    }, {
        key: '_onLayout',
        value: function _onLayout(event) {
            var onLayout = this.props.onLayout;

            if (this._onLayoutInitDone) {
                this._initPositionsAndInterpolators();
                this.snapToItem(this._activeItem, false, false, false, false);
            } else {
                this._onLayoutInitDone = true;
            }

            if (onLayout) {
                onLayout(event);
            }
        }
    }, {
        key: '_snapScroll',
        value: function _snapScroll(delta) {
            var swipeThreshold = this.props.swipeThreshold;

            if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {
                this._scrollEndActive = this._scrollStartActive;
            }

            if (this._scrollStartActive !== this._scrollEndActive) {
                this.snapToItem(this._scrollEndActive);
            } else {
                if (delta > 0) {
                    if (delta > swipeThreshold) {
                        this.snapToItem(this._scrollStartActive + 1);
                    } else {
                        this.snapToItem(this._scrollEndActive);
                    }
                } else if (delta < 0) {
                    if (delta < -swipeThreshold) {
                        this.snapToItem(this._scrollStartActive - 1);
                    } else {
                        this.snapToItem(this._scrollEndActive);
                    }
                } else {
                    this.snapToItem(this._scrollEndActive);
                }
            }
        }
    }, {
        key: '_onSnap',
        value: function _onSnap(index) {
            var onSnapToItem = this.props.onSnapToItem;


            if (!this._flatlist) {
                return;
            }

            this._canFireCallback = false;
            onSnapToItem && onSnapToItem(index);
        }
    }, {
        key: 'startAutoplay',
        value: function startAutoplay() {
            var _this8 = this;

            var _props14 = this.props,
                autoplayInterval = _props14.autoplayInterval,
                autoplayDelay = _props14.autoplayDelay;


            if (this._autoplaying) {
                return;
            }

            clearTimeout(this._autoplayTimeout);
            this._autoplayTimeout = setTimeout(function () {
                _this8._autoplaying = true;
                _this8._autoplayInterval = setInterval(function () {
                    if (_this8._autoplaying) {
                        _this8.snapToNext();
                    }
                }, autoplayInterval);
            }, autoplayDelay);
        }
    }, {
        key: 'stopAutoplay',
        value: function stopAutoplay() {
            this._autoplaying = false;
            clearInterval(this._autoplayInterval);
        }
    }, {
        key: 'snapToItem',
        value: function snapToItem(index) {
            var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

            var _this9 = this;

            var initial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
            var lockScroll = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
            var _props15 = this.props,
                enableMomentum = _props15.enableMomentum,
                onSnapToItem = _props15.onSnapToItem;

            var itemsLength = this._getCustomDataLength();

            if (!itemsLength || !this._flatlist || !this._flatlist._listRef) {
                return;
            }

            if (!index || index < 0) {
                index = 0;
            } else if (itemsLength > 0 && index >= itemsLength) {
                index = itemsLength - 1;
            }

            if (index !== this._previousActiveItem) {
                this._previousActiveItem = index;

                if (lockScroll && this._canLockScroll()) {
                    this._lockScroll();
                }

                if (onSnapToItem && fireCallback) {
                    this._canFireCallback = true;
                }
            }

            this._itemToSnapTo = index;
            this._scrollOffsetRef = this._positions[index] && this._positions[index].start;
            this._onScrollTriggered = false;

            this._flatlist.scrollToIndex({
                index: index,
                viewPosition: 0,
                viewOffset: 0,
                animated: animated
            });

            if (enableMomentum) {
                if (IS_IOS && !initial) {
                    this._ignoreNextMomentum = true;
                }

                if (index === 0 || index === itemsLength - 1) {
                    clearTimeout(this._edgeItemTimeout);
                    this._edgeItemTimeout = setTimeout(function () {
                        if (!initial && index === _this9._activeItem && !_this9._onScrollTriggered) {
                            _this9._onScroll();
                        }
                    }, 250);
                }
            }
        }
    }, {
        key: 'snapToNext',
        value: function snapToNext() {
            var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            var itemsLength = this._getCustomDataLength();

            var newIndex = this._activeItem + 1;
            if (newIndex > itemsLength - 1) {
                if (!this._enableLoop()) {
                    return;
                }
                newIndex = 0;
            }
            this.snapToItem(newIndex, animated);
        }
    }, {
        key: 'snapToPrev',
        value: function snapToPrev() {
            var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            var itemsLength = this._getCustomDataLength();

            var newIndex = this._activeItem - 1;
            if (newIndex < 0) {
                if (!this._enableLoop()) {
                    return;
                }
                newIndex = itemsLength - 1;
            }
            this.snapToItem(newIndex, animated);
        }
    }, {
        key: '_renderItem',
        value: function _renderItem(_ref) {
            var item = _ref.item,
                index = _ref.index;
            var interpolators = this.state.interpolators;
            var _props16 = this.props,
                renderItem = _props16.renderItem,
                sliderWidth = _props16.sliderWidth,
                sliderHeight = _props16.sliderHeight,
                itemWidth = _props16.itemWidth,
                itemHeight = _props16.itemHeight,
                slideStyle = _props16.slideStyle,
                inactiveSlideScale = _props16.inactiveSlideScale,
                inactiveSlideOpacity = _props16.inactiveSlideOpacity,
                vertical = _props16.vertical,
                hasParallaxImages = _props16.hasParallaxImages;


            var animatedValue = interpolators && interpolators[index];

            if (!animatedValue || !animatedValue.opacity && animatedValue.opacity !== 0 || !animatedValue.scale && animatedValue.scale !== 0) {
                return false;
            }

            var animate = this._shouldAnimateSlides();
            var Component = animate ? _reactNative.Animated.View : _reactNative.View;
            var animatedStyle = {
                opacity: animate ? animatedValue.opacity.interpolate({
                    inputRange: [0, 1],
                    outputRange: [inactiveSlideOpacity, 1]
                }) : 1,
                transform: [{
                    scale: animate ? animatedValue.scale.interpolate({
                        inputRange: [0, 1],
                        outputRange: [inactiveSlideScale, 1]
                    }) : 1
                }]
            };

            var parallaxProps = hasParallaxImages ? {
                scrollPosition: this._scrollPos,
                carouselRef: this._flatlist,
                vertical: vertical,
                sliderWidth: sliderWidth,
                sliderHeight: sliderHeight,
                itemWidth: itemWidth,
                itemHeight: itemHeight
            } : undefined;

            return _react3.default.createElement(
                Component,
                { style: [slideStyle, animatedStyle], pointerEvents: 'box-none', __source: {
                        fileName: _jsxFileName,
                        lineNumber: 941
                    }
                },
                renderItem({ item: item, index: index }, parallaxProps)
            );
        }
    }, {
        key: 'render',
        value: function render() {
            var _this10 = this;

            var hideCarousel = this.state.hideCarousel;
            var _props17 = this.props,
                containerCustomStyle = _props17.containerCustomStyle,
                contentContainerCustomStyle = _props17.contentContainerCustomStyle,
                data = _props17.data,
                enableMomentum = _props17.enableMomentum,
                firstItem = _props17.firstItem,
                itemWidth = _props17.itemWidth,
                itemHeight = _props17.itemHeight,
                keyExtractor = _props17.keyExtractor,
                loopClonesPerSide = _props17.loopClonesPerSide,
                renderItem = _props17.renderItem,
                sliderWidth = _props17.sliderWidth,
                sliderHeight = _props17.sliderHeight,
                style = _props17.style,
                vertical = _props17.vertical;


            if (!data || !renderItem) {
                return false;
            }

            var containerStyle = [containerCustomStyle || style || {}, hideCarousel ? { opacity: 0 } : {}, vertical ? { height: sliderHeight, flexDirection: 'column' } : { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }];
            var contentContainerStyle = [contentContainerCustomStyle || {}, vertical ? {
                paddingTop: this._getContainerInnerMargin(),
                paddingBottom: this._getContainerInnerMargin(true)
            } : {
                paddingLeft: this._getContainerInnerMargin(),
                paddingRight: this._getContainerInnerMargin(true)
            }];
            var visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;
            var initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;
            var initialNumToRender = visibleItems + initialNumPerSide * 2;
            var maxToRenderPerBatch = 1 + initialNumToRender * 2;
            var windowSize = maxToRenderPerBatch;

            return _react3.default.createElement(AnimatedFlatList, _extends({
                decelerationRate: enableMomentum ? 0.9 : 'fast',
                showsHorizontalScrollIndicator: false,
                showsVerticalScrollIndicator: false,
                overScrollMode: 'never',
                automaticallyAdjustContentInsets: false,
                directionalLockEnabled: true,
                pinchGestureEnabled: false,
                scrollsToTop: false,
                initialNumToRender: initialNumToRender,
                maxToRenderPerBatch: maxToRenderPerBatch,
                windowSize: windowSize
            }, this.props, {
                ref: function ref(c) {
                    if (c) {
                        _this10._flatlist = c._component;
                    }
                },
                data: this._getCustomData(),
                renderItem: this._renderItem,

                getItemLayout: this._getItemLayout,
                keyExtractor: keyExtractor || this._getKeyExtractor,
                initialScrollIndex: firstItem ? this._getFirstItem(firstItem) : undefined,
                numColumns: 1,
                style: containerStyle,
                contentContainerStyle: contentContainerStyle,
                horizontal: !vertical,
                inverted: this._needsRTLAdaptations(),
                scrollEventThrottle: 1,
                onScroll: this._onScrollHandler,
                onScrollBeginDrag: this._onScrollBeginDrag,
                onScrollEndDrag: this._onScrollEndDrag,
                onMomentumScrollEnd: this._onMomentumScrollEnd,
                onResponderRelease: this._onTouchRelease,
                onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,
                onTouchStart: this._onTouchStart,
                onLayout: this._onLayout,
                __source: {
                    fileName: _jsxFileName,
                    lineNumber: 998
                }
            }));
        }
    }, {
        key: 'realIndex',
        get: function get() {
            return this._activeItem;
        }
    }, {
        key: 'currentIndex',
        get: function get() {
            return this._getDataIndex(this._activeItem);
        }
    }, {
        key: 'currentScrollPosition',
        get: function get() {
            return this._currentContentOffset;
        }
    }]);

    return Carousel;
}(_react2.Component), _class.propTypes = _extends({}, _reactNative.FlatList.propTypes, {
    data: _propTypes2.default.array.isRequired,
    renderItem: _propTypes2.default.func.isRequired,
    itemWidth: _propTypes2.default.number,
    itemHeight: _propTypes2.default.number,
    sliderWidth: _propTypes2.default.number,
    sliderHeight: _propTypes2.default.number,
    activeSlideAlignment: _propTypes2.default.oneOf(['center', 'end', 'start']),
    activeSlideOffset: _propTypes2.default.number,
    apparitionDelay: _propTypes2.default.number,
    autoplay: _propTypes2.default.bool,
    autoplayDelay: _propTypes2.default.number,
    autoplayInterval: _propTypes2.default.number,
    callbackOffsetMargin: _propTypes2.default.number,
    containerCustomStyle: _reactNative.ViewPropTypes ? _reactNative.ViewPropTypes.style : _reactNative.View.propTypes.style,
    contentContainerCustomStyle: _reactNative.ViewPropTypes ? _reactNative.ViewPropTypes.style : _reactNative.View.propTypes.style,
    enableMomentum: _propTypes2.default.bool,
    enableSnap: _propTypes2.default.bool,
    firstItem: _propTypes2.default.number,
    hasParallaxImages: _propTypes2.default.bool,
    inactiveSlideOpacity: _propTypes2.default.number,
    inactiveSlideScale: _propTypes2.default.number,
    lockScrollWhileSnapping: _propTypes2.default.bool,
    loop: _propTypes2.default.bool,
    loopClonesPerSide: _propTypes2.default.number,
    slideStyle: _reactNative.Animated.View.propTypes.style,
    shouldOptimizeUpdates: _propTypes2.default.bool,
    swipeThreshold: _propTypes2.default.number,
    vertical: _propTypes2.default.bool,
    onSnapToItem: _propTypes2.default.func
}), _class.defaultProps = {
    activeSlideAlignment: 'center',
    activeSlideOffset: 20,
    apparitionDelay: 250,
    autoplay: false,
    autoplayDelay: 5000,
    autoplayInterval: 3000,
    callbackOffsetMargin: 5,
    containerCustomStyle: {},
    contentContainerCustomStyle: {},
    enableMomentum: false,
    enableSnap: true,
    firstItem: 0,
    hasParallaxImages: false,
    inactiveSlideOpacity: 0.7,
    inactiveSlideScale: 0.9,
    lockScrollWhileSnapping: false,
    loop: false,
    loopClonesPerSide: 3,
    slideStyle: {},
    shouldOptimizeUpdates: true,
    swipeThreshold: 20,
    vertical: false
}, _temp));

exports.default = Carousel;